backend/Dockerfile
FROM python:3.12-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    ffmpeg \
    && rm -rf /var/lib/apt/lists/*

# Set working directory
WORKDIR /app

# Copy requirements first for better caching
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Expose port
EXPOSE 8000

# Start the application
CMD ["uvicorn", "main:app", "--host", "127.0.0.1", "--port", "8000"]
================================================
backend/main.py
================================================
from fastapi import FastAPI, File, UploadFile, Depends, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from sqlalchemy.orm import Session
from pydantic import BaseModel
import os
import tempfile
import signal
import sys
from datetime import datetime
from dotenv import load_dotenv
import traceback
import logging

# Load environment variables from .env file
load_dotenv()

# basic logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
logger = logging.getLogger("summeet")

from models import get_db, Transcription
from services import convert_to_mp3, transcribe_audio, summarize_meeting, save_summary_as_markdown

app = FastAPI(title="Summeet API", version="1.0.0")

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # tighten this in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
async def root():
    return {"message": "Summeet API", "version": "1.0.0"}

@app.post("/upload")
async def upload_audio(
    file: UploadFile = File(...),
    db: Session = Depends(get_db)
):
    """
    Upload and transcribe audio file.
    This endpoint prints full traceback to server logs on error to aid debugging.
    """
    tmp_file_path = None
    mp3_path = None

    try:
        # Save uploaded file temporarily and check size before writing large files
        MAX_FILE_SIZE = 100 * 1024 * 1024  # 100MB
        content = await file.read()

        if len(content) > MAX_FILE_SIZE:
            raise HTTPException(status_code=413, detail="File too large. Maximum size is 100MB.")

        # Use NamedTemporaryFile to ensure a stable path; keep on disk for external tools
        with tempfile.NamedTemporaryFile(delete=False, suffix=f"_{file.filename}") as tmp_file:
            tmp_file.write(content)
            tmp_file_path = tmp_file.name

        logger.info("Saved upload to temporary file: %s", tmp_file_path)

        # Defensive: ensure tmp file exists
        if not tmp_file_path or not os.path.exists(tmp_file_path):
            raise RuntimeError(f"Uploaded file was not saved correctly: {tmp_file_path}")

        # Convert to MP3 (services.convert_to_mp3 should raise on failure)
        try:
            mp3_path = convert_to_mp3(tmp_file_path)
            logger.info("convert_to_mp3 returned: %s", mp3_path)
        except Exception as ex:
            logger.error("convert_to_mp3 failed for %s", tmp_file_path)
            traceback.print_exc()
            raise RuntimeError(f"convert_to_mp3 failed: {ex}")

        # Ensure mp3_path was produced
        if not mp3_path or not os.path.exists(mp3_path):
            raise RuntimeError(f"MP3 file not produced. mp3_path={mp3_path}")

        # Transcribe audio
        try:
            transcript_data = transcribe_audio(mp3_path)
            logger.info("transcription completed for: %s", mp3_path)
        except Exception as ex:
            logger.error("transcribe_audio failed for %s", mp3_path)
            traceback.print_exc()
            raise RuntimeError(f"transcribe_audio failed: {ex}")

        # Validate transcript_data structure
        text = transcript_data.get("text") if isinstance(transcript_data, dict) else None
        speakers = transcript_data.get("speakers") if isinstance(transcript_data, dict) else None
        if text is None:
            raise RuntimeError(f"transcribe_audio returned invalid result: {transcript_data}")

        # Save to database
        transcription = Transcription(
            filename=file.filename,
            transcript=text,
            speakers=speakers if speakers is not None else "[]"
        )
        db.add(transcription)
        db.commit()
        db.refresh(transcription)

        return {
            "id": transcription.id,
            "filename": transcription.filename,
            "transcript": transcription.transcript,
            "speakers": transcription.speakers,
            "created_at": transcription.created_at
        }

    except HTTPException:
        # Re-raise FastAPI HTTPExceptions unchanged
        raise
    except Exception as e:
        # Print full traceback to server logs for debugging (will show WinError 2)
        logger.exception("Unhandled error in /upload: %s", e)
        # Return a sanitized error message to the client, include exception text for quick debug
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        # Attempt to clean up files; never raise from cleanup
        try:
            if tmp_file_path and os.path.exists(tmp_file_path):
                os.unlink(tmp_file_path)
                logger.debug("Removed temporary file: %s", tmp_file_path)
        except Exception:
            logger.debug("Failed to remove tmp file", exc_info=True)
        try:
            if mp3_path and os.path.exists(mp3_path):
                os.unlink(mp3_path)
                logger.debug("Removed mp3 file: %s", mp3_path)
        except Exception:
            logger.debug("Failed to remove mp3 file", exc_info=True)


class DirectTranscriptRequest(BaseModel):
    filename: str
    transcript: str
    speakers: str = "[]"

@app.post("/transcript")
async def save_direct_transcript(
    request: DirectTranscriptRequest,
    db: Session = Depends(get_db)
):
    """Save direct transcript input to database"""
    try:
        transcription = Transcription(
            filename=request.filename,
            transcript=request.transcript,
            speakers=request.speakers
        )
        db.add(transcription)
        db.commit()
        db.refresh(transcription)

        return {
            "id": transcription.id,
            "filename": transcription.filename,
            "transcript": transcription.transcript,
            "speakers": transcription.speakers,
            "created_at": transcription.created_at
        }

    except Exception as e:
        logger.exception("Error saving direct transcript")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/transcription/{transcription_id}")
async def get_transcription(
    transcription_id: int,
    db: Session = Depends(get_db)
):
    """Get transcription by ID"""
    transcription = db.query(Transcription).filter(Transcription.id == transcription_id).first()
    if not transcription:
        raise HTTPException(status_code=404, detail="Transcription not found")

    return {
        "id": transcription.id,
        "filename": transcription.filename,
        "transcript": transcription.transcript,
        "speakers": transcription.speakers,
        "summary": transcription.summary,
        "created_at": transcription.created_at
    }

@app.post("/summarize/{transcription_id}")
async def create_summary(
    transcription_id: int,
    language: str = "en",
    temperature: float = 0.8,
    db: Session = Depends(get_db)
):
    """Generate summary for transcription"""
    transcription = db.query(Transcription).filter(Transcription.id == transcription_id).first()
    if not transcription:
        raise HTTPException(status_code=404, detail="Transcription not found")

    try:
        # Parse speakers if available
        speaker_table = None
        if transcription.speakers:
            try:
                import json
                speakers_data = json.loads(transcription.speakers)
                speaker_table = [[s.get('speaker', 'Unknown'), s.get('description', '')] for s in speakers_data]
            except json.JSONDecodeError:
                logger.warning("Could not parse speakers JSON for transcription %s", transcription_id)

        summary = summarize_meeting(
            transcription.transcript,
            speaker_table=speaker_table,
            system_prompt_language=language,
            temperature=temperature
        )

        transcription.summary = summary
        db.commit()

        return {"summary": summary}

    except Exception as e:
        logger.exception("Error creating summary for %s", transcription_id)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/export/{transcription_id}")
async def export_markdown(
    transcription_id: int,
    db: Session = Depends(get_db)
):
    """Export transcription as markdown file"""
    transcription = db.query(Transcription).filter(Transcription.id == transcription_id).first()
    if not transcription:
        raise HTTPException(status_code=404, detail="Transcription not found")

    try:
        markdown_path = save_summary_as_markdown(
            transcription.transcript,
            transcription.summary or "",
            transcription.filename or f"meeting_{transcription.id}"
        )

        return FileResponse(
            markdown_path,
            media_type='text/markdown',
            filename=f"{transcription.filename or f'meeting_{transcription.id}'}_summary.md"
        )

    except Exception as e:
        logger.exception("Error exporting markdown for %s", transcription_id)
        raise HTTPException(status_code=500, detail=str(e))


def signal_handler(sig, frame):
    """Handle SIGINT (Ctrl+C) and SIGTERM signals"""
    logger.info("Received shutdown signal. Gracefully shutting down...")
    sys.exit(0)

if __name__ == "__main__":
    import uvicorn

    # Register signal handlers
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    logger.info("ðŸš€ Starting Summeet API...")
    try:
        # run via python main.py to surface tracebacks in the console
        uvicorn.run(app, host="127.0.0.1", port=8000)
    except KeyboardInterrupt:
        logger.info("ðŸ›‘ Server stopped by user")
    except Exception as e:
        logger.exception("âŒ Server error during startup: %s", e)
    finally:
        logger.info("ðŸ‘‹ Summeet API shutdown complete")
=========================================================================
backend/models.py
=========================================================================

from sqlalchemy import create_engine, Column, Integer, String, Text, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
import os

# Get data directory from environment variable, default to /app/data
DATA_DIR = os.getenv("DATA_DIR", "/app/data")

# Ensure data directory exists
os.makedirs(DATA_DIR, exist_ok=True)

# SQLite database configuration
DATABASE_URL = f"sqlite:///{DATA_DIR}/database.db"

engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

class Transcription(Base):
    __tablename__ = "transcriptions"

    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String, index=True)
    transcript = Column(Text)
    speakers = Column(Text)  # JSON string
    summary = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

# Create tables
Base.metadata.create_all(bind=engine)

def get_db():
    """Database dependency"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
=============================================
backend/requirements.txt
=============================================
fastapi==0.104.1
uvicorn==0.24.0
sqlalchemy==2.0.23
assemblyai==0.21.0
openai==1.3.7
python-multipart==0.0.6
python-dotenv==1.0.0
httpx==0.27.1
=============================================
backend/services.py
=============================================
import os
import tempfile
import subprocess
import shutil
import logging
import json
from pathlib import Path
from datetime import datetime

import assemblyai as aai
from openai import OpenAI

logger = logging.getLogger("summeet.services")
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")

# Config loads (fall back to env/defaults)
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "")
OPENAI_BASE_URL = os.getenv("OPENAI_BASE_URL", "https://api.openai.com/v1")
ASSEMBLYAI_API_KEY = os.getenv("ASSEMBLYAI_API_KEY", "")
TEXT_MODEL_NAME = os.getenv("TEXT_MODEL_NAME", "gemini/gemini-2.0-flash")

# OpenAI client container
client = None

def initialize_openai_client():
    """Initialize OpenAI client with clear error behavior."""
    global client
    try:
        if not OPENAI_API_KEY:
            raise ValueError("OPENAI_API_KEY not set")

        client = OpenAI(api_key=OPENAI_API_KEY, base_url=OPENAI_BASE_URL, timeout=60.0)
        # optional lightweight test could go here but may be skipped in CI/dev
        logger.info("OpenAI client initialized (base_url=%s, model=%s)", OPENAI_BASE_URL, TEXT_MODEL_NAME)
        return True
    except Exception as e:
        client = None
        logger.warning("OpenAI client initialization failed: %s", e)
        return False

# Initialize on import if possible
initialize_openai_client()

# Initialize AssemblyAI
try:
    if not ASSEMBLYAI_API_KEY:
        logger.warning("ASSEMBLYAI_API_KEY not set; transcription calls will fail until set.")
    aai.settings.api_key = ASSEMBLYAI_API_KEY
    aai.settings.http_timeout = 900  # 15 minutes for long uploads/transcribes
    logger.info("AssemblyAI client initialized (api_key set: %s)", bool(ASSEMBLYAI_API_KEY))
except Exception as e:
    logger.exception("Failed to configure AssemblyAI SDK: %s", e)


# --- FFmpeg helpers ---------------------------------------------------------
def find_ffmpeg():
    """
    Locate ffmpeg executable. Prefer FFMPEG_PATH env var, then search PATH.
    Returns full path to ffmpeg or None if not found.
    """
    env_path = os.getenv("FFMPEG_PATH")
    if env_path:
        p = Path(env_path)
        if p.exists() and p.is_file():
            return str(p)

    # Try typical names on PATH
    for name in ("ffmpeg", "ffmpeg.exe"):
        which = shutil.which(name)
        if which:
            return which

    return None


def convert_to_mp3(input_path: str, target_samplerate: int = 16000) -> str:
    """
    Convert audio at input_path to an mp3 file and return path to mp3.
    If input_path already ends with .mp3, returns input_path.
    Raises RuntimeError with actionable messages on failure.
    """
    input_p = Path(input_path)
    if not input_p.exists():
        raise RuntimeError(f"Input file does not exist: {input_path}")

    # Shortcut if already mp3
    if input_p.suffix.lower() == ".mp3":
        logger.debug("Input is already mp3: %s", input_path)
        return str(input_p)

    ffmpeg_cmd = find_ffmpeg()
    if not ffmpeg_cmd:
        raise RuntimeError(
            "ffmpeg not found. Install ffmpeg and ensure it's on PATH, "
            "or set the FFMPEG_PATH environment variable to the full path of ffmpeg.exe.\n"
            "Example (PowerShell temporary): $env:FFMPEG_PATH = 'C:\\ffmpeg\\bin\\ffmpeg.exe'\n"
            "Or permanent (cmd): setx FFMPEG_PATH \"C:\\ffmpeg\\bin\\ffmpeg.exe\""
        )

    # Place output next to input or in temp dir
    out_dir = input_p.parent if input_p.parent.exists() else Path(tempfile.gettempdir())
    out_name = input_p.stem + "_converted.mp3"
    out_path = out_dir / out_name

    command = [
        ffmpeg_cmd,
        "-y",                 # overwrite
        "-i", str(input_p),
        "-ac", "1",           # mono
        "-ar", str(target_samplerate),
        "-vn",                # no video
        str(out_path)
    ]

    logger.info("Running ffmpeg command: %s ...", " ".join([Path(command[0]).name] + command[1:4]) + " ...")
    try:
        # Capture stderr to present useful message if ffmpeg fails
        proc = subprocess.run(command, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
    except subprocess.CalledProcessError as cpe:
        stderr = cpe.stderr.decode("utf-8", errors="replace") if cpe.stderr else ""
        logger.error("ffmpeg conversion failed; stderr: %s", stderr)
        raise RuntimeError(f"ffmpeg failed: {stderr}") from cpe
    except FileNotFoundError as fnf:
        # defensive: should not happen due to find_ffmpeg but handle gracefully
        logger.exception("ffmpeg executable not found at: %s", ffmpeg_cmd)
        raise RuntimeError(f"ffmpeg executable not found at: {ffmpeg_cmd}") from fnf

    if not out_path.exists():
        raise RuntimeError(f"ffmpeg reported success but output file missing: {out_path}")

    logger.info("ffmpeg conversion created: %s", out_path)
    return str(out_path)


# --- Temp cleanup -----------------------------------------------------------
def clean_temp_files(file_list):
    """Attempt to delete files; log warnings if unable to delete."""
    for file_path in file_list:
        try:
            if file_path and Path(file_path).exists():
                Path(file_path).unlink()
                logger.debug("Deleted temp file: %s", file_path)
        except Exception as e:
            logger.warning("Could not delete temp file %s: %s", file_path, e)


# --- Transcription via AssemblyAI ------------------------------------------
def transcribe_audio(audio_file, word_boost="", language="auto"):
    """
    Transcribe the audio file using AssemblyAI.
    Returns dict with transcript text and speakers JSON string.
    Raises RuntimeError on failure.
    """
    if not audio_file:
        raise ValueError("No audio file provided")

    temp_files = []
    mp3_file = None
    try:
        mp3_file = convert_to_mp3(audio_file)
        temp_files.append(mp3_file)

        # Build config kwargs
        config_kwargs = {
            "speaker_labels": True,
            "language_detection": True if language == "auto" else False,
            "language_code": None if language == "auto" else language,
            "word_boost": [word.strip() for word in word_boost.split(",")] if word_boost else None,
        }
        # Remove keys with None
        config = aai.TranscriptionConfig(**{k: v for k, v in config_kwargs.items() if v is not None})
        transcriber = aai.Transcriber()

        logger.info("Uploading for transcription: %s", mp3_file)
        transcript = transcriber.transcribe(mp3_file, config=config)
        logger.info("Transcription request submitted. id=%s status=%s", getattr(transcript, "id", None), getattr(transcript, "status", None))

        # Wait / process depending on SDK behavior; keep current pattern
        if transcript.status == aai.TranscriptStatus.completed:
            transcript_text = ""
            speaker_set = set()

            if getattr(transcript, "utterances", None):
                for utterance in transcript.utterances:
                    speaker = utterance.speaker if getattr(utterance, "speaker", None) else "Unknown"
                    transcript_text += f"Speaker {speaker}: {utterance.text}\n"
                    speaker_set.add(speaker)
            else:
                # Fallback to whole-text field
                transcript_text = transcript.text if getattr(transcript, "text", None) else "(No speech detected or transcription empty)"
                speaker_set.add("Unknown")

            # Guarantee at least one speaker if text exists
            if not speaker_set and transcript_text and transcript_text != "(No speech detected or transcription empty)":
                speaker_set.add("Unknown")

            # Sort speakers (numeric speakers first)
            try:
                sorted_speakers = sorted(list(speaker_set), key=lambda x: (int(x) if str(x).isdigit() else float('inf'), x))
            except Exception:
                sorted_speakers = sorted(list(speaker_set))

            speakers_data = [{"speaker": speaker, "description": ""} for speaker in sorted_speakers]

            return {
                "text": transcript_text,
                "speakers": json.dumps(speakers_data)
            }
        elif transcript.status == aai.TranscriptStatus.error:
            raise RuntimeError(f"Transcription Error: {getattr(transcript, 'error', 'unknown')}")
        else:
            # In case the SDK returns other intermediate statuses, surface them
            raise RuntimeError(f"Transcription ended with status: {getattr(transcript, 'status', 'unknown')}")

    except Exception as e:
        logger.exception("Error during transcription process")
        raise RuntimeError(f"Error during transcription process: {e}")
    finally:
        clean_temp_files(temp_files)


# --- Summarization via OpenAI ----------------------------------------------
SYSTEM_PROMPTS = {
    "en": "...",  # keep your full prompts; truncated here for brevity if copying
    "cn": "..."
}

def summarize_meeting(transcript, speaker_table=None, system_prompt_language="en", temperature=0.8):
    """Summarize meeting transcript with OpenAI. Requires initialized client."""
    if not transcript or transcript.strip() == "" or transcript.strip() == "(No speech detected or transcription empty)":
        return "No transcript available to summarize."

    if client is None:
        logger.warning("OpenAI client is None, attempting to reinitialize")
        if not initialize_openai_client():
            raise RuntimeError(
                f"OpenAI client is not initialized. Check environment variables: OPENAI_API_KEY, OPENAI_BASE_URL, TEXT_MODEL_NAME"
            )

    system_prompt = SYSTEM_PROMPTS.get(system_prompt_language, SYSTEM_PROMPTS.get("en", ""))

    try:
        speaker_info_str = ""
        if speaker_table:
            speaker_info_str = "\n\nSpeaker Information:\n" + "\n".join(
                [f"Speaker {row[0]}: {row[1]}" for row in speaker_table if len(row) > 1 and row[1].strip()]
            )

        content = f"Transcription:\n{transcript}\n----{speaker_info_str}"
        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": content}
        ]

        logger.info("Sending summarization request to OpenAI (model=%s)", TEXT_MODEL_NAME)
        response = client.chat.completions.create(
            model=TEXT_MODEL_NAME,
            messages=messages,
            temperature=temperature
        )

        # Validate response structure
        summary = None
        try:
            summary = response.choices[0].message.content.strip()
        except Exception:
            # fallback extraction for different SDK shapes
            summary = getattr(response, "text", None) or str(response)

        if not summary:
            return "(Summary generation failed or produced empty result)"
        return summary

    except Exception as e:
        logger.exception("Summarization error")
        raise RuntimeError(f"Summarization error: {e}")


# --- Save markdown ----------------------------------------------------------
def save_summary_as_markdown(transcript, summary, filename_base=None):
    """Save summary and transcript as markdown file in system temp dir."""
    now_str = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"{(filename_base or 'meeting')}_{now_str}.md"

    save_dir = os.path.join(tempfile.gettempdir(), "meeting_summaries")
    os.makedirs(save_dir, exist_ok=True)
    file_path = os.path.join(save_dir, filename)

    content = f"## {filename_base or 'Meeting'} - {now_str}\n\n***\n\n### Summary\n\n{summary}\n\n"
    if transcript:
        content += f"\n\n***\n\n### Full Transcript\n\n{transcript}\n\n"

    try:
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(content)
        logger.info("Summary saved to: %s", file_path)
        return file_path
    except Exception as e:
        logger.exception("Error saving markdown file")
        raise RuntimeError(f"Error saving markdown file: {e}")
